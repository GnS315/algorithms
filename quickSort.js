const quickSort = (array) => {
  // Условие для прекращения рекурсии, в таком случае вернем сам массив
  if (array.length <= 1) {
    return array;
  }

  // Ищем индекс для опорной точки
  const pivotIdx = Math.floor(array.length / 2);
  // Значение опорной точки
  const pivot = array[pivotIdx];

  const less = []; // Массив для значений меньше опорного
  const greater = []; // Массив для значений больше опорного

  for (let i = 0; i < array.length; i++) {
    // Пропускаем, если значения индекса равно индексу опорного значения
    if (i === pivotIdx) {
      continue;
    }
    // Делим на два массива со значениями больше и меньше опорного
    if (array[i] < pivot) {
      less.push(array[i]);
    } else {
      greater.push(array[i]);
    }
  }
  /*
  * Возвращаем массив, в котором разворачиваем значения из функции со
  * значениями меньше и больше опороного и посередине значение опорной
  * точки. Таким образом функция будет рекурсивно выполняться, пока
  * условие для прекращения рекурсии не выполнится и не вернется
  * отсортированный массив
  * */

  return [...quickSort(less), pivot, ...quickSort(greater)];
};